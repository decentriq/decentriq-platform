"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Request(google.protobuf.message.Message):
    """=========================================================================================================
    CONTAINER

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DELTAREQUEST_FIELD_NUMBER: builtins.int
    EXTENSIONMESSAGE_FIELD_NUMBER: builtins.int
    @property
    def deltaRequest(self) -> global___DataNoncePubkey: ...
    @property
    def extensionMessage(self) -> global___ExtensionMessage: ...
    def __init__(self,
        *,
        deltaRequest : typing.Optional[global___DataNoncePubkey] = ...,
        extensionMessage : typing.Optional[global___ExtensionMessage] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"deltaRequest",b"deltaRequest",u"extensionMessage",b"extensionMessage",u"request",b"request"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"deltaRequest",b"deltaRequest",u"extensionMessage",b"extensionMessage",u"request",b"request"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"request",b"request"]) -> typing.Optional[typing_extensions.Literal["deltaRequest","extensionMessage"]]: ...
global___Request = Request

class ExtensionMessage(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    PAYLOAD_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    payload: builtins.bytes = ...
    def __init__(self,
        *,
        name : typing.Text = ...,
        payload : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"name",b"name",u"payload",b"payload"]) -> None: ...
global___ExtensionMessage = ExtensionMessage

class Response(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SUCCESSFULRESPONSE_FIELD_NUMBER: builtins.int
    UNSUCCESSFULRESPONSE_FIELD_NUMBER: builtins.int
    successfulResponse: builtins.bytes = ...
    unsuccessfulResponse: typing.Text = ...
    def __init__(self,
        *,
        successfulResponse : builtins.bytes = ...,
        unsuccessfulResponse : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"response",b"response",u"successfulResponse",b"successfulResponse",u"unsuccessfulResponse",b"unsuccessfulResponse"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"response",b"response",u"successfulResponse",b"successfulResponse",u"unsuccessfulResponse",b"unsuccessfulResponse"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"response",b"response"]) -> typing.Optional[typing_extensions.Literal["successfulResponse","unsuccessfulResponse"]]: ...
global___Response = Response

class DataNoncePubkey(google.protobuf.message.Message):
    """=========================================================================================================
    ENCRYPTED MESSAGE FORMAT

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATA_FIELD_NUMBER: builtins.int
    NONCE_FIELD_NUMBER: builtins.int
    PUBKEY_FIELD_NUMBER: builtins.int
    PKI_FIELD_NUMBER: builtins.int
    data: builtins.bytes = ...
    nonce: builtins.bytes = ...
    pubkey: builtins.bytes = ...
    @property
    def pki(self) -> global___Pki: ...
    def __init__(self,
        *,
        data : builtins.bytes = ...,
        nonce : builtins.bytes = ...,
        pubkey : builtins.bytes = ...,
        pki : typing.Optional[global___Pki] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"auth",b"auth",u"pki",b"pki"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"auth",b"auth",u"data",b"data",u"nonce",b"nonce",u"pki",b"pki",u"pubkey",b"pubkey"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"auth",b"auth"]) -> typing.Optional[typing_extensions.Literal["pki"]]: ...
global___DataNoncePubkey = DataNoncePubkey

class Pki(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CERTCHAINPEM_FIELD_NUMBER: builtins.int
    SIGNATURE_FIELD_NUMBER: builtins.int
    IDMAC_FIELD_NUMBER: builtins.int
    certChainPem: builtins.bytes = ...
    signature: builtins.bytes = ...
    idMac: builtins.bytes = ...
    def __init__(self,
        *,
        certChainPem : builtins.bytes = ...,
        signature : builtins.bytes = ...,
        idMac : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"certChainPem",b"certChainPem",u"idMac",b"idMac",u"signature",b"signature"]) -> None: ...
global___Pki = Pki

class DataNonce(google.protobuf.message.Message):
    """=========================================================================================================
    ENCRYPTED SEALED MESSAGED FORMAT

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATA_FIELD_NUMBER: builtins.int
    NONCE_FIELD_NUMBER: builtins.int
    data: builtins.bytes = ...
    nonce: builtins.bytes = ...
    def __init__(self,
        *,
        data : builtins.bytes = ...,
        nonce : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"data",b"data",u"nonce",b"nonce"]) -> None: ...
global___DataNonce = DataNonce

class SealedEncryptedMessage(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ENCRYPTEDMESSAGE_FIELD_NUMBER: builtins.int
    SEALINGKEYPARAMS_FIELD_NUMBER: builtins.int
    @property
    def encryptedMessage(self) -> global___DataNonce: ...
    sealingKeyParams: builtins.bytes = ...
    def __init__(self,
        *,
        encryptedMessage : typing.Optional[global___DataNonce] = ...,
        sealingKeyParams : builtins.bytes = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"encryptedMessage",b"encryptedMessage"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"encryptedMessage",b"encryptedMessage",u"sealingKeyParams",b"sealingKeyParams"]) -> None: ...
global___SealedEncryptedMessage = SealedEncryptedMessage

class EncryptionHeader(google.protobuf.message.Message):
    """=========================================================================================================
    ENCRYPTED STORAGE FORMAT

    * LAYOUT
      Every stored file has the following layout: (EH || Enc(VH || CH || CB))
        EH = EncryptionHeader: specifies how the rest of the file is encrypted, including key ids.
        VH = VersionHeader: specifies a version number allowing for non-protobuf-supported changes in the rest of the layout.
        CH = ChunkHeader: specifies common integrity-checked values as well as format specification for the body.
        CB = ChunkBody(blob): the actual body of the file, including potential additional metadata header when needed.

    * VERSIONING
      Encrypted data is consumed only by enclaves, so we only need to be *read* compatible, but not *write*. Changes in
      the client-enclave protocol should be reflected in infrastructure versioning, e.g. if we change the result format.
      The following changes are anticipated:
        1. Protobuf-compatible encrypted format(CH || CB => CH' || CB') changes
             Ideally changes should conform to https://developers.google.com/protocol-buffers/docs/proto#updating. As
             long as we do this we don't need to write any special code or bump version numbers.
        2. Protobuf-incompatible encrypted format(CH || CB => X) changes
             If we change the data format completely (for example switch to FlatBuffer) then we still need to keep the
             VersionHeader definition as-is, bump the version number, and write version-specific code to handle the new
             data version, as well as potentially keep the old version's code around.

             For example, say the pre-bump code reading a file looks as follows:
               ...
               let version_header: VersionHeader = prost::Message::decode(&mut buffer)?;
               if version_header.version != 0 {
                 Err(format!("Cannot decode version {}", version_header.version))?;
               }
               let chunk_header: ChunkHeader = prost::Message::decode(&mut buffer)?;
               ...

             The post-bump code would then look as follows:
               ...
               let version_header: VersionHeader = prost::Message::decode(&mut buffer)?;
               match version_header.version {
                 0 => {
                   let chunk_header: ChunkHeader = prost::Message::decode(&mut buffer)?;
                   ... old code ...
                 }
                 1 => {
                   let fancy_fb_chunk: FbChunk = flatbuffers::decode(&mut buffer)?;
                   ... new code ...
                 }
                 _ => {
                   Err(format!("Cannot decode version {}", version_header.version))?;
                 }
               }
               ...

             Note that we don't need to write special code for *writing* (can write flatbuffers directly) because we only
             need read-compatibility.
        3. Encryption (EH => EH') changes
             If the encryption method itself changes (change of cipher, change of key identification), then ideally a new
             `oneof` variant should be added to `EncryptionHeader`, and should be handled accordingly in code when
             reading. Note that `EncryptionHeader` is plaintext, so we must make sure attackers cannot do "re-versioning"
             attacks triggering unintended codepaths. Authenticated encryption is designed to prevent this, so plaintext
             versioning may be used in this context. Change in encryption method may also be coupled with a complete
             restructuring of the encrypted data format (including `VersionHeader`). This is *only* possible if the
             encryption method actually changes.
             To illustrate why, say we introduced a new EH `oneof` variant that actually encodes the same encryption
             method as `EncryptionHeader::ChilyKey`, but changes the internal structuring of the encoded data. Now an
             attacker can create an encrypted data blob with the old format but specifying the new encryption variant.
             Because the encryption method is the same, the data blob will pass the authenticated (de)encryption phase,
             which means code handling the old format will be called with newly formatted data.

    Encryption header (unencrypted)
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CHILYKEY_FIELD_NUMBER: builtins.int
    @property
    def chilyKey(self) -> global___ChilyKey: ...
    def __init__(self,
        *,
        chilyKey : typing.Optional[global___ChilyKey] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"chilyKey",b"chilyKey",u"encryptionHeader",b"encryptionHeader"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"chilyKey",b"chilyKey",u"encryptionHeader",b"encryptionHeader"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"encryptionHeader",b"encryptionHeader"]) -> typing.Optional[typing_extensions.Literal["chilyKey"]]: ...
global___EncryptionHeader = EncryptionHeader

class ChilyKey(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ENCRYPTIONNONCE_FIELD_NUMBER: builtins.int
    encryptionNonce: builtins.bytes = ...
    def __init__(self,
        *,
        encryptionNonce : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"encryptionNonce",b"encryptionNonce"]) -> None: ...
global___ChilyKey = ChilyKey

class VersionHeader(google.protobuf.message.Message):
    """Version header (encrypted)"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VERSION_FIELD_NUMBER: builtins.int
    version: builtins.int = ...
    def __init__(self,
        *,
        version : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"version",b"version"]) -> None: ...
global___VersionHeader = VersionHeader

class ChunkHeader(google.protobuf.message.Message):
    """Data format header (encrypted)"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXTRAENTROPY_FIELD_NUMBER: builtins.int
    extraEntropy: builtins.bytes = ...
    def __init__(self,
        *,
        extraEntropy : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"extraEntropy",b"extraEntropy"]) -> None: ...
global___ChunkHeader = ChunkHeader
