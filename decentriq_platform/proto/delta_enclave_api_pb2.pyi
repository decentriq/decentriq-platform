"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import sys

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class Request(google.protobuf.message.Message):
    """=========================================================================================================
    CONTAINER
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DELTAREQUEST_FIELD_NUMBER: builtins.int
    EXTENSIONMESSAGE_FIELD_NUMBER: builtins.int
    @property
    def deltaRequest(self) -> global___DataNoncePubkey: ...
    @property
    def extensionMessage(self) -> global___ExtensionMessage: ...
    def __init__(
        self,
        *,
        deltaRequest: global___DataNoncePubkey | None = ...,
        extensionMessage: global___ExtensionMessage | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["deltaRequest", b"deltaRequest", "extensionMessage", b"extensionMessage", "request", b"request"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["deltaRequest", b"deltaRequest", "extensionMessage", b"extensionMessage", "request", b"request"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["request", b"request"]) -> typing_extensions.Literal["deltaRequest", "extensionMessage"] | None: ...

global___Request = Request

class ExtensionMessage(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    PAYLOAD_FIELD_NUMBER: builtins.int
    name: builtins.str
    payload: builtins.bytes
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        payload: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["name", b"name", "payload", b"payload"]) -> None: ...

global___ExtensionMessage = ExtensionMessage

class Response(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUCCESSFULRESPONSE_FIELD_NUMBER: builtins.int
    UNSUCCESSFULRESPONSE_FIELD_NUMBER: builtins.int
    successfulResponse: builtins.bytes
    unsuccessfulResponse: builtins.str
    def __init__(
        self,
        *,
        successfulResponse: builtins.bytes = ...,
        unsuccessfulResponse: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["response", b"response", "successfulResponse", b"successfulResponse", "unsuccessfulResponse", b"unsuccessfulResponse"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["response", b"response", "successfulResponse", b"successfulResponse", "unsuccessfulResponse", b"unsuccessfulResponse"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["response", b"response"]) -> typing_extensions.Literal["successfulResponse", "unsuccessfulResponse"] | None: ...

global___Response = Response

class DataNoncePubkey(google.protobuf.message.Message):
    """=========================================================================================================
    ENCRYPTED MESSAGE FORMAT
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATA_FIELD_NUMBER: builtins.int
    NONCE_FIELD_NUMBER: builtins.int
    PUBKEY_FIELD_NUMBER: builtins.int
    data: builtins.bytes
    nonce: builtins.bytes
    pubkey: builtins.bytes
    def __init__(
        self,
        *,
        data: builtins.bytes = ...,
        nonce: builtins.bytes = ...,
        pubkey: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["data", b"data", "nonce", b"nonce", "pubkey", b"pubkey"]) -> None: ...

global___DataNoncePubkey = DataNoncePubkey

class DataNonce(google.protobuf.message.Message):
    """=========================================================================================================
    ENCRYPTED SEALED MESSAGED FORMAT
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATA_FIELD_NUMBER: builtins.int
    NONCE_FIELD_NUMBER: builtins.int
    data: builtins.bytes
    nonce: builtins.bytes
    def __init__(
        self,
        *,
        data: builtins.bytes = ...,
        nonce: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["data", b"data", "nonce", b"nonce"]) -> None: ...

global___DataNonce = DataNonce

class SealedEncryptedMessage(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENCRYPTEDMESSAGE_FIELD_NUMBER: builtins.int
    SEALINGKEYPARAMS_FIELD_NUMBER: builtins.int
    @property
    def encryptedMessage(self) -> global___DataNonce: ...
    sealingKeyParams: builtins.bytes
    def __init__(
        self,
        *,
        encryptedMessage: global___DataNonce | None = ...,
        sealingKeyParams: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["encryptedMessage", b"encryptedMessage"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["encryptedMessage", b"encryptedMessage", "sealingKeyParams", b"sealingKeyParams"]) -> None: ...

global___SealedEncryptedMessage = SealedEncryptedMessage

class EncryptionHeader(google.protobuf.message.Message):
    """* LAYOUT
      Every stored file has the following layout: (EH || Enc(VH || CH || CB))
        EH = EncryptionHeader: specifies how the rest of the file is encrypted, including key ids.
        VH = VersionHeader: specifies a version number allowing for non-protobuf-supported changes in the rest of the layout.
        CH = ChunkHeader: specifies common integrity-checked values as well as format specification for the body.
        CB = ChunkBody(blob): the actual body of the file, including potential additional metadata header when needed.

    * VERSIONING
      Encrypted data is consumed only by enclaves, so we only need to be *read* compatible, but not *write*. Changes in
      the client-enclave protocol should be reflected in infrastructure versioning, e.g. if we change the result format.
      The following changes are anticipated:
        1. Protobuf-compatible encrypted format(CH || CB => CH' || CB') changes
             Ideally changes should conform to https://developers.google.com/protocol-buffers/docs/proto#updating. As
             long as we do this we don't need to write any special code or bump version numbers.
        2. Protobuf-incompatible encrypted format(CH || CB => X) changes
             If we change the data format completely (for example switch to FlatBuffer) then we still need to keep the
             VersionHeader definition as-is, bump the version number, and write version-specific code to handle the new
             data version, as well as potentially keep the old version's code around.

             For example, say the pre-bump code reading a file looks as follows:
               ...
               let version_header: VersionHeader = prost::Message::decode(&mut buffer)?;
               if version_header.version != 0 {
                 Err(format!("Cannot decode version {}", version_header.version))?;
               }
               let chunk_header: ChunkHeader = prost::Message::decode(&mut buffer)?;
               ...

             The post-bump code would then look as follows:
               ...
               let version_header: VersionHeader = prost::Message::decode(&mut buffer)?;
               match version_header.version {
                 0 => {
                   let chunk_header: ChunkHeader = prost::Message::decode(&mut buffer)?;
                   ... old code ...
                 }
                 1 => {
                   let fancy_fb_chunk: FbChunk = flatbuffers::decode(&mut buffer)?;
                   ... new code ...
                 }
                 _ => {
                   Err(format!("Cannot decode version {}", version_header.version))?;
                 }
               }
               ...

             Note that we don't need to write special code for *writing* (can write flatbuffers directly) because we only
             need read-compatibility.
        3. Encryption (EH => EH') changes
             If the encryption method itself changes (change of cipher, change of key identification), then ideally a new
             `oneof` variant should be added to `EncryptionHeader`, and should be handled accordingly in code when
             reading. Note that `EncryptionHeader` is plaintext, so we must make sure attackers cannot do "re-versioning"
             attacks triggering unintended codepaths. Authenticated encryption is designed to prevent this, so plaintext
             versioning may be used in this context. Change in encryption method may also be coupled with a complete
             restructuring of the encrypted data format (including `VersionHeader`). This is *only* possible if the
             encryption method actually changes.
             To illustrate why, say we introduced a new EH `oneof` variant that actually encodes the same encryption
             method as `EncryptionHeader::ChilyKey`, but changes the internal structuring of the encoded data. Now an
             attacker can create an encrypted data blob with the old format but specifying the new encryption variant.
             Because the encryption method is the same, the data blob will pass the authenticated (de)encryption phase,
             which means code handling the old format will be called with newly formatted data.

    Encryption header (unencrypted)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CHILYKEY_FIELD_NUMBER: builtins.int
    @property
    def chilyKey(self) -> global___ChilyKey: ...
    def __init__(
        self,
        *,
        chilyKey: global___ChilyKey | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["chilyKey", b"chilyKey", "encryptionHeader", b"encryptionHeader"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["chilyKey", b"chilyKey", "encryptionHeader", b"encryptionHeader"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["encryptionHeader", b"encryptionHeader"]) -> typing_extensions.Literal["chilyKey"] | None: ...

global___EncryptionHeader = EncryptionHeader

class ChilyKey(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENCRYPTIONNONCE_FIELD_NUMBER: builtins.int
    encryptionNonce: builtins.bytes
    def __init__(
        self,
        *,
        encryptionNonce: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["encryptionNonce", b"encryptionNonce"]) -> None: ...

global___ChilyKey = ChilyKey

class VersionHeader(google.protobuf.message.Message):
    """Version header (encrypted)"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VERSION_FIELD_NUMBER: builtins.int
    version: builtins.int
    def __init__(
        self,
        *,
        version: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["version", b"version"]) -> None: ...

global___VersionHeader = VersionHeader

class ChunkHeader(google.protobuf.message.Message):
    """Data format header (encrypted)"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXTRAENTROPY_FIELD_NUMBER: builtins.int
    UNTRUSTEDCONTENTSIZE_FIELD_NUMBER: builtins.int
    UNTRUSTEDCHUNKCONTENTSIZES_FIELD_NUMBER: builtins.int
    extraEntropy: builtins.bytes
    """Additional entropy to ensure low-entropy content is not bruteforce-able."""
    untrustedContentSize: builtins.int
    """A field indicating the size of the underlying data. Currently this should only be set for manifest chunks where
    it indicates the size of the overall underlying dataset.
    WARNING: This field should be treated as a potential attack vector. Ideally a potential mismatch between this
    size and the actual size should be handled in common low-level code such as `ChunkReader`.
    """
    @property
    def untrustedChunkContentSizes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """A field indicating the size of the underlying chunks' contents, meant to speed up seeks. Should only be set for
        manifest chunks.
        WARNING: This field should be treated as a potential attack vector. Ideally a potential mismatch between these
        sizes and the actual chunk content sizes should be handled in common low-level code such as `ChunkReader`.
        """
    def __init__(
        self,
        *,
        extraEntropy: builtins.bytes = ...,
        untrustedContentSize: builtins.int | None = ...,
        untrustedChunkContentSizes: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_untrustedContentSize", b"_untrustedContentSize", "untrustedContentSize", b"untrustedContentSize"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_untrustedContentSize", b"_untrustedContentSize", "extraEntropy", b"extraEntropy", "untrustedChunkContentSizes", b"untrustedChunkContentSizes", "untrustedContentSize", b"untrustedContentSize"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_untrustedContentSize", b"_untrustedContentSize"]) -> typing_extensions.Literal["untrustedContentSize"] | None: ...

global___ChunkHeader = ChunkHeader
