syntax = "proto2";
package waterfront;

import "column_type.proto";
import "data_room.proto";

message WaterfrontRequest {
    oneof waterfront_request {
        SqlQueryRequest sqlQueryRequest = 2;
        CreateDataRoomRequest createDataRoomRequest = 5;
        PublishDatasetToDataRoomRequest publishDatasetToDataRoomRequest = 6;
        RetrieveDataRoomRequest retrieveDataRoomRequest = 7;
        ValidateDatasetRequest validateDatasetRequest = 8;
    }
}

message WaterfrontResponse {
    oneof waterfront_response {
        string failure = 1;
        SqlQueryResponse sqlQueryResponse = 3;
        CreateDataRoomResponse createDataRoomResponse = 6;
        PublishDatasetToDataRoomResponse publishDatasetToDataRoomResponse = 7;
        RetrieveDataRoomResponse retrieveDataRoomResponse = 8;
        ValidateDatasetResponse validateDatasetResponse = 9;
    }
}

message CreateDataRoomRequest {
    required data_room.DataRoom dataRoom = 1;
}

message CreateDataRoomResponse {
    oneof create_data_room_response {
        bytes dataRoomHash = 1;
        DataRoomValidationError dataRoomValidationError = 2;
    }
}

message DataRoomValidationError {
    required string message = 1;
    optional uint64 queryIndex = 2;
    optional uint64 columnIndex = 3;
    optional uint64 tableIndex = 4;
    optional uint64 roleIndex = 5;
    optional uint64 permissionIndex = 6;
    optional uint64 constraintIndex = 7;
}

message PublishDatasetToDataRoomRequest {
    required bytes manifestHash = 1;
    required bytes dataRoomHash = 2;
    required string dataRoomTableName = 3;
    required EncryptionKey encryptionKey = 4;
}

message PublishDatasetToDataRoomResponse {
}

message ValidateDatasetRequest {
    required bytes manifestHash = 1;
    required EncryptionKey encryptionKey = 2;
}
// If validation fails because of malformed input,
// communicate back to the sender the row that failed
// along with a descriptive message. 
message ValidateDatasetFailure {
    required string message = 1;
    optional uint64 row = 2;
}

message ValidateDatasetResponse {
    optional ValidateDatasetFailure failure = 1;    
}

message SqlQueryRequest {
    required string queryName = 1;
    required bytes dataRoomHash = 2;
}

// If the content bytes here are empty, then we use this to indicate
// that the query is not finished yet. This facilitates polling.
message SqlQueryResponse {
    optional bytes data = 1;
}

message RetrieveDataRoomRequest {
    required bytes dataRoomHash = 1;
}

message RetrieveDataRoomResponse {
    required data_room.DataRoom dataRoom = 1;
}

// Storage
message EncryptionKey {
    required bytes material = 1;
    required bytes salt = 2;
}

message TableSchema {
    repeated NamedColumn namedColumns = 1;
}

message NamedColumn {
    required string name = 1;
    required column_type.ColumnType columnType = 2;
}

message DatasetManifest {
    required bytes digestHash = 1;
    required TableSchema schema = 2;
}
