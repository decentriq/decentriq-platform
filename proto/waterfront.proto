syntax = "proto2";
package waterfront;

import "column_type.proto";
import "data_room.proto";

message WaterfrontRequest {
    oneof waterfront_request {
        SqlQueryRequest sqlQueryRequest = 2;
        CreateDataRoomRequest createDataRoomRequest = 5;
        PublishDatasetToDataRoomRequest publishDatasetToDataRoomRequest = 6;
        RetrieveDataRoomRequest retrieveDataRoomRequest = 7;
        ValidateDatasetRequest validateDatasetRequest = 8;
        RetrieveAuditLogRequest retrieveAuditLogRequest = 9;
        RetrieveDataRoomStatusRequest retrieveDataRoomStatusRequest = 10;
        UpdateDataRoomStatusRequest updateDataRoomStatusRequest = 11;
        RetrievePublishedDatasetRequest retrievePublishedDatasetRequest = 12;
        RemovePublishedDatasetRequest removePublishedDatasetRequest = 13;
        JobStatusRequest jobStatusRequest = 14;
        GetResultsRequest getResultsRequest = 15;
    }
}

message WaterfrontResponse {
    oneof waterfront_response {
        string failure = 1;
        SqlQueryResponse sqlQueryResponse = 3;
        CreateDataRoomResponse createDataRoomResponse = 6;
        PublishDatasetToDataRoomResponse publishDatasetToDataRoomResponse = 7;
        RetrieveDataRoomResponse retrieveDataRoomResponse = 8;
        ValidateDatasetResponse validateDatasetResponse = 9;
        RetrieveAuditLogResponse retrieveAuditLogResponse = 10;
        RetrieveDataRoomStatusResponse retrieveDataRoomStatusResponse = 11;
        UpdateDataRoomStatusResponse updateDataRoomStatusResponse = 12;
        RetrievePublishedDatasetResponse retrievePublishedDatasetResponse = 13;
        RemovePublishedDatasetResponse removePublishedDatasetResponse = 14;
        JobStatusResponse jobStatusResponse = 15;
    }
}

message AuthenticationData {
    required string role = 1;
    optional string passwordSha256 = 2;
}

message CreateDataRoomRequest {
    required data_room.DataRoom dataRoom = 1;
}

message CreateDataRoomResponse {
    oneof create_data_room_response {
        bytes dataRoomHash = 1;
        DataRoomValidationError dataRoomValidationError = 2;
    }
}

message DataRoomValidationError {
    required string message = 1;
    optional uint64 queryIndex = 2;
    optional uint64 columnIndex = 3;
    optional uint64 tableIndex = 4;
    optional uint64 roleIndex = 5;
    optional uint64 permissionIndex = 6;
    optional uint64 constraintIndex = 7;
}

message PublishDatasetToDataRoomRequest {
    required bytes manifestHash = 1;
    required bytes dataRoomHash = 2;
    required string dataRoomTableName = 3;
    required EncryptionKey encryptionKey = 4;
    required AuthenticationData auth = 5;
}

message PublishDatasetToDataRoomResponse {
}

message ValidateDatasetRequest {
    required bytes manifestHash = 1;
    required EncryptionKey encryptionKey = 2;
}
// If validation fails because of malformed input,
// communicate back to the sender the row that failed
// along with a descriptive message.
message ValidateDatasetFailure {
    required string message = 1;
    optional uint64 row = 2;
}

message ValidateDatasetResponse {
    optional ValidateDatasetFailure failure = 1;
}

message SqlQueryRequest {
    required string queryName = 1;
    required bytes dataRoomHash = 2;
    required AuthenticationData auth = 5;
}

// If the content bytes here are empty, then we use this to indicate
// that the query is not finished yet. This facilitates polling.
message SqlQueryResponse {
    oneof sql_query_response {
        SqlQueryInProgress inProgress = 1;
        SqlQueryFinished finished = 2;
    }
}

message SqlQueryInProgress {
    required bytes jobId = 1;
}

message SqlQueryFinished {
    required bytes data = 1;
    repeated string header = 2;
}

message JobStatusRequest {
    required bytes jobId = 1;
    required AuthenticationData auth = 2;
}

// this communicates back the three possible job
// states. Error, the job id supplied is
// not recognized. If false, the job is still running. 
// if true, the job is complete.
message JobStatusResponse {
    required bool completed = 1;
}

// get job results. This
// currently resubmits the query internally, 
// as if one had been doing the full-weight query polling.
// the reply comes back as SqlQueryResponse.
message GetResultsRequest {
    required bytes jobId = 1;
    required AuthenticationData auth = 2;
}

message RetrieveDataRoomRequest {
    required bytes dataRoomHash = 1;
    required AuthenticationData auth = 5;
}

message RetrieveDataRoomResponse {
    required data_room.DataRoom dataRoom = 1;
}

message RetrieveAuditLogRequest {
    required bytes dataRoomHash = 1;
    required AuthenticationData auth = 2;
}

// logs come back as a big csv type bunch of text.
message RetrieveAuditLogResponse {
    optional bytes data = 1;
}

enum DataRoomStatus {
    Active = 1;
    Stopped = 2;
}

message RetrieveDataRoomStatusRequest {
    required bytes dataRoomHash = 1;
    required AuthenticationData auth = 2;
}

message RetrieveDataRoomStatusResponse {
    required DataRoomStatus status = 1;
}

message UpdateDataRoomStatusRequest {
    required bytes dataRoomHash = 1;
    required AuthenticationData auth = 2;
    required DataRoomStatus status = 3;
}

message UpdateDataRoomStatusResponse {
}

message RetrievePublishedDatasetRequest {
    required bytes dataRoomHash = 1;
    required AuthenticationData auth = 2;
}

message PublishedDataset {
    required string table = 1;
    required string user = 2;
    required uint64 timestamp = 3;
    required bytes dataset_hash = 4;
}

message RetrievePublishedDatasetResponse {
    repeated PublishedDataset publishedDatasets = 1;
}

message RemovePublishedDatasetRequest {
    required bytes manifestHash = 1;
    required bytes dataRoomHash = 2;
    required string dataRoomTableName = 3;
    required AuthenticationData auth = 4;
}

message RemovePublishedDatasetResponse {}

// Storage
message EncryptionKey {
    required bytes material = 1;
    required bytes salt = 2;
}

message TableSchema {
    repeated NamedColumn namedColumns = 1;
}

message NamedColumn {
    required string name = 1;
    required column_type.ColumnType columnType = 2;
}

message DatasetManifest {
    required bytes digestHash = 1;
    required TableSchema schema = 2;
}
